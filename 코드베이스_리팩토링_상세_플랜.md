# 🔄 코드베이스 리팩토링 상세 실행 플랜

## 📋 현재 상태 분석

### 🔴 중대한 문제점들

1. **타입 시스템 중복 및 분산**
   - `lib/data.ts`: 레거시 Google Sheets 기반 `PersonaData` 인터페이스 정의
   - `types/persona.ts`: Supabase 기반 타입 정의
   - `lib/api/projects.ts`: 별도의 `Project` 인터페이스 중복 정의
   - `types/project.ts`와 `lib/api/projects.ts`에서 타입 불일치

2. **API 라우트 구조 불일치**
   - `/api/supabase/` 불필요한 네임스페이스 사용
   - RESTful 원칙 미준수
   - 일관성 없는 응답 형식

3. **레거시 코드 잔존**
   - `lib/data.ts`의 Google Sheets API 호출 함수들
   - 사용되지 않는 `/api/sheets` 엔드포인트 참조

---

## 🎯 단계별 상세 리팩토링 계획

### **Phase 1: 타입 시스템 통합 및 정리**

#### 📝 **Phase 1.1: 레거시 타입 제거 및 통합**

**작업 내용:**
1. `lib/data.ts`에서 레거시 `PersonaData` 인터페이스 제거
2. Google Sheets 관련 함수들(`fetchPersonaById`, `fetchPersonas`, `fetchKeywords`) 완전 제거
3. `types/` 폴더에 통합 타입 시스템 구축

**파일 변경사항:**

```
삭제할 파일:
- lib/data.ts (전체 파일 삭제)

수정할 파일:
- types/index.ts (새로 생성)
- types/api.ts (새로 생성)  
- types/components.ts (새로 생성)
- types/business.ts (새로 생성)
```

**🎯 AI 프롬프트:**
```
Phase 1.1 - 레거시 타입 제거 및 통합:

1. lib/data.ts 파일을 완전히 삭제하라
2. types/ 폴더에 다음 파일들을 생성하라:

types/index.ts:
```typescript
// 모든 타입 통합 export
export * from './database'
export * from './persona'  
export * from './project'
export * from './interviewee'
export * from './api'
export * from './components'
export * from './business'
```

types/api.ts:
```typescript
// API 요청/응답 공통 타입
export interface ApiResponse<T> {
  data: T
  message?: string
  error?: string
  success?: boolean
}

export interface PaginatedApiResponse<T> extends ApiResponse<T[]> {
  pagination?: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}

export interface ErrorResponse {
  error: string
  message?: string
  statusCode?: number
}
```

types/components.ts:
```typescript
// 컴포넌트 Props 타입들
export interface BaseComponentProps {
  className?: string
  children?: React.ReactNode
}

export interface PersonaCardProps extends BaseComponentProps {
  persona: PersonaData
  onClick?: () => void
  isSelected?: boolean
}

export interface ProjectCardProps extends BaseComponentProps {
  project: Project
  onEdit?: () => void
  onDelete?: () => void
}
```

types/business.ts:
```typescript
// 비즈니스 로직 관련 타입
export interface WorkflowQueueItem {
  id: string
  fileName: string
  status: 'pending' | 'processing' | 'completed' | 'failed'
  progress: number
  error?: string
  startTime?: Date
  endTime?: Date
}

export interface ChatMessage {
  id: string
  content: string
  role: 'user' | 'assistant'
  timestamp: Date
  personaId?: string
}
```

3. 모든 컴포넌트와 API에서 lib/data.ts import를 제거하고 types/index.ts에서 import하도록 변경하라
```

**예상 에러와 해결방법:**

| 에러 유형 | 발생 위치 | 해결 방법 |
|-----------|-----------|-----------|
| `Cannot find module './lib/data'` | 컴포넌트 파일들 | `import { PersonaData } from '../types'`로 변경 |
| `fetchPersonaById is not defined` | 페르소나 관련 컴포넌트 | Supabase 기반 새로운 API 함수로 교체 |
| `PersonaData type mismatch` | 기존 컴포넌트들 | Supabase 스키마와 일치하는 타입으로 수정 |

#### 📝 **Phase 1.2: API 타입 통합**

**작업 내용:**
1. `lib/api/projects.ts`의 중복 타입 정의 제거  
2. `types/project.ts`와 통합
3. 일관된 API 응답 타입 적용

**🎯 AI 프롬프트:**
```
Phase 1.2 - API 타입 통합:

1. lib/api/projects.ts에서 Project, CreateProjectData, ProjectMember 인터페이스들을 제거하라
2. types/project.ts의 타입들을 사용하도록 import 수정:
```typescript
import { 
  Project, 
  CreateProjectData, 
  ProjectMember,
  ProjectApiResponse 
} from '../../types'
```

3. 모든 API 함수의 반환 타입을 ApiResponse<T> 형태로 통일하라
4. lib/api/persona-criteria.ts도 동일하게 타입 통합 적용하라
```

**예상 Import 수정사항:**
```typescript
// 변경 전
import { Project } from '../api/projects'

// 변경 후  
import { Project } from '../types'
```

---

### **Phase 2: API 라우트 리팩토링**

#### 📝 **Phase 2.1: /api/supabase/ 네임스페이스 제거**

**작업 내용:**
1. `/api/supabase/` 경로를 도메인 중심으로 재구성
2. RESTful 원칙 적용
3. 일관된 응답 형식 구축

**파일 이동 및 변경:**

```
이동할 파일들:
app/api/supabase/projects/route.ts → app/api/projects/route.ts
app/api/supabase/projects/[id]/route.ts → app/api/projects/[id]/route.ts
app/api/supabase/projects/[id]/members/route.ts → app/api/projects/[id]/members/route.ts
app/api/supabase/projects/members/route.ts → app/api/projects/members/route.ts

app/api/supabase/interviewee/route.ts → app/api/interviews/route.ts
app/api/supabase/interviewee/[id]/route.ts → app/api/interviews/[id]/route.ts

app/api/supabase/persona/route.ts → app/api/personas/route.ts  
app/api/supabase/persona/sync/route.ts → app/api/personas/sync/route.ts

app/api/supabase/persona-criteria/route.ts → app/api/persona-criteria/route.ts

삭제할 폴더:
app/api/supabase/ (전체 폴더)
```

**🎯 AI 프롬프트:**
```
Phase 2.1 - API 라우트 리팩토링:

1. 다음과 같이 파일들을 이동하라:
   - app/api/supabase/projects/ → app/api/projects/
   - app/api/supabase/interviewee/ → app/api/interviews/
   - app/api/supabase/persona/ → app/api/personas/
   - app/api/supabase/persona-criteria/ → app/api/persona-criteria/

2. 각 API 라우트 파일에서 일관된 응답 형식 적용:
```typescript
// 성공 응답
return NextResponse.json({
  data: result,
  message: "성공 메시지",
  success: true
}, { status: 200 })

// 에러 응답
return NextResponse.json({
  error: "에러 메시지",
  success: false
}, { status: 400 })
```

3. HTTP 메서드별 적절한 핸들러 구현:
   - GET: 조회
   - POST: 생성  
   - PUT: 전체 업데이트
   - PATCH: 부분 업데이트
   - DELETE: 삭제
```

#### 📝 **Phase 2.2: API 클라이언트 함수 업데이트**

**작업 내용:**
1. `lib/api/` 폴더의 모든 함수들이 새로운 엔드포인트 사용
2. 새로운 응답 형식에 맞게 에러 핸들링 수정

**🎯 AI 프롬프트:**
```
Phase 2.2 - API 클라이언트 업데이트:

1. lib/api/projects.ts의 모든 fetch URL을 업데이트하라:
```typescript
// 변경 전
const url = `/api/supabase/projects?company_id=${companyId}&user_id=${userId}`

// 변경 후
const url = `/api/projects?company_id=${companyId}&user_id=${userId}`
```

2. lib/api/persona-criteria.ts도 동일하게 업데이트:
```typescript
// 변경 전
const response = await fetch(`/api/supabase/persona-criteria?${params}`)

// 변경 후  
const response = await fetch(`/api/persona-criteria?${params}`)
```

3. 새로운 응답 형식에 맞게 에러 핸들링 수정:
```typescript
if (!response.ok) {
  const errorData = await response.json().catch(() => ({}))
  throw new Error(errorData.error || '요청에 실패했습니다.')
}

const { data, success, error } = await response.json()
if (!success) {
  throw new Error(error || '알 수 없는 오류가 발생했습니다.')
}
return data
```
```

**예상 Import 수정사항:**

| 컴포넌트/훅 | 변경 전 | 변경 후 |
|-------------|---------|---------|
| useProjects | `/api/supabase/projects` | `/api/projects` |
| 프로젝트 컴포넌트들 | `/api/supabase/projects/*` | `/api/projects/*` |
| 인터뷰 관련 컴포넌트 | `/api/supabase/interviewee` | `/api/interviews` |

---

### **Phase 3: 컴포넌트 구조 최적화**

#### 📝 **Phase 3.1: 인덱스 파일 생성**

**작업 내용:**
1. 누락된 인덱스 파일들 생성
2. 컴포넌트 export 통합
3. import 경로 단순화

**생성할 파일들:**

```
components/ui/index.ts (새로 생성)
components/auth/index.ts (기존 파일 보완)
components/chat/index.ts (기존 파일 확인)
components/modal/index.ts (기존 파일 확인)
components/persona/index.ts (기존 파일 확인)
components/project/index.ts (기존 파일 확인)
components/search/index.ts (기존 파일 확인)
components/shared/index.ts (기존 파일 확인)
```

**🎯 AI 프롬프트:**
```
Phase 3.1 - 인덱스 파일 생성:

1. components/ui/index.ts를 생성하고 모든 UI 컴포넌트를 export하라:
```typescript
// shadcn/ui 컴포넌트들
export * from './button'
export * from './card'
export * from './input'
export * from './label'
export * from './dialog'
export * from './dropdown-menu'
export * from './sheet'
export * from './toast'
export * from './toaster'
export * from './use-toast'
// ... 모든 UI 컴포넌트들
```

2. 각 도메인 컴포넌트 폴더의 index.ts 파일들을 확인하고 누락된 export가 있으면 추가하라

3. 모든 컴포넌트에서 상대 경로 import를 절대 경로로 변경:
```typescript
// 변경 전
import { Button } from '../ui/button'
import { Card } from '../ui/card'

// 변경 후
import { Button, Card } from '@/components/ui'
```
```

#### 📝 **Phase 3.2: 컴포넌트 타입 정의 분리**

**🎯 AI 프롬프트:**
```
Phase 3.2 - 컴포넌트 타입 분리:

1. types/components.ts에 모든 컴포넌트 Props 타입을 중앙화하라
2. 각 컴포넌트 파일에서 인라인 타입 정의를 제거하고 types/components.ts에서 import하라
3. 공통으로 사용되는 Props 패턴을 Base 타입으로 추상화하라
```

---

### **Phase 4: 유틸리티 함수 재구성**

#### 📝 **Phase 4.1: lib/utils 세분화**

**작업 내용:**
1. `lib/utils.ts`를 기능별로 분리
2. 새로운 유틸리티 모듈 구조 생성

**생성할 파일들:**
```
lib/utils/index.ts (새로 생성)
lib/utils/cn.ts (새로 생성)
lib/utils/format.ts (새로 생성)
lib/utils/validation.ts (새로 생성)
lib/utils/date.ts (새로 생성)
```

**🎯 AI 프롬프트:**
```
Phase 4.1 - 유틸리티 함수 세분화:

1. lib/utils.ts의 내용을 분석하고 다음과 같이 분리하라:

lib/utils/cn.ts:
```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

lib/utils/format.ts:
```typescript
// 날짜, 텍스트, 숫자 포맷팅 함수들
export function formatDate(date: string | Date): string {
  // 구현
}

export function formatCurrency(amount: number): string {
  // 구현  
}

export function truncateText(text: string, maxLength: number): string {
  // 구현
}
```

lib/utils/validation.ts:
```typescript
// 검증 함수들
export function isValidEmail(email: string): boolean {
  // 구현
}

export function isValidPassword(password: string): boolean {
  // 구현
}
```

lib/utils/index.ts:
```typescript
export * from './cn'
export * from './format'  
export * from './validation'
export * from './date'
```

2. 모든 컴포넌트에서 import 경로를 업데이트하라:
```typescript
// 변경 전
import { cn } from '@/lib/utils'

// 변경 후  
import { cn } from '@/lib/utils'
// 또는 세부적으로
import { cn } from '@/lib/utils/cn'
```
```

#### 📝 **Phase 4.2: 특수 목적 파일 재배치**

**파일 이동:**
```
lib/persona-data.ts → lib/data/persona-data.ts
lib/file-utils.ts → lib/utils/file.ts
```

**🎯 AI 프롬프트:**
```
Phase 4.2 - 특수 목적 파일 재배치:

1. lib/ 폴더에 data/ 서브폴더를 생성하라
2. persona-data.ts를 lib/data/로 이동하라
3. file-utils.ts를 lib/utils/file.ts로 이동하라
4. 모든 import 경로를 업데이트하라:
```typescript
// 변경 전
import { ... } from '@/lib/persona-data'
import { ... } from '@/lib/file-utils'

// 변경 후
import { ... } from '@/lib/data/persona-data'  
import { ... } from '@/lib/utils/file'
```
```

---

### **Phase 5: API 계층 최적화**

#### 📝 **Phase 5.1: API 함수 도메인별 재정리**

**작업 내용:**
1. `lib/api/` 폴더 구조를 도메인 중심으로 재구성
2. 중복 로직 제거 및 공통 API 클라이언트 추상화

**생성/수정할 파일들:**
```
lib/api/base.ts (새로 생성) - 공통 API 클라이언트
lib/api/auth.ts (새로 생성)
lib/api/interviews.ts (새로 생성)  
lib/api/personas.ts (새로 생성)
lib/api/projects.ts (기존 파일 개선)
lib/api/persona-criteria.ts (기존 파일 개선)
lib/api/index.ts (새로 생성)
```

**🎯 AI 프롬프트:**
```
Phase 5.1 - API 계층 최적화:

1. lib/api/base.ts에 공통 API 클라이언트 생성:
```typescript
import { ApiResponse, ErrorResponse } from '@/types'

class ApiClient {
  private baseURL = ''

  async request<T>(
    endpoint: string, 
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    })

    if (!response.ok) {
      const errorData: ErrorResponse = await response.json().catch(() => ({
        error: `HTTP ${response.status}: ${response.statusText}`
      }))
      throw new Error(errorData.error)
    }

    return response.json()
  }

  get<T>(endpoint: string) {
    return this.request<T>(endpoint, { method: 'GET' })
  }

  post<T>(endpoint: string, data: any) {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    })
  }

  put<T>(endpoint: string, data: any) {
    return this.request<T>(endpoint, {
      method: 'PUT', 
      body: JSON.stringify(data),
    })
  }

  delete<T>(endpoint: string) {
    return this.request<T>(endpoint, { method: 'DELETE' })
  }
}

export const apiClient = new ApiClient()
```

2. 모든 API 함수들을 새로운 apiClient 사용하도록 리팩토링하라
3. 일관된 에러 핸들링과 타입 안전성 확보하라
```

#### 📝 **Phase 5.2: React Query 통합 최적화**

**🎯 AI 프롬프트:**
```
Phase 5.2 - React Query 최적화:

1. hooks/ 폴더의 모든 API 관련 훅들을 새로운 API 클라이언트와 통합하라
2. 쿼리 키 네이밍 컨벤션을 일관성 있게 적용하라:
```typescript
export const queryKeys = {
  projects: {
    all: ['projects'] as const,
    byCompany: (companyId: string) => ['projects', 'company', companyId] as const,
    detail: (id: string) => ['projects', 'detail', id] as const,
  },
  personas: {
    all: ['personas'] as const,
    byProject: (projectId: string) => ['personas', 'project', projectId] as const,
  },
  // ...
}
```

3. 낙관적 업데이트와 캐시 무효화 로직을 개선하라
```

---

### **Phase 6: 정적 리소스 및 문서 정리**

#### 📝 **Phase 6.1: 불필요한 파일 제거**

**삭제할 파일들:**
```
public/placeholder-logo.png
public/placeholder-logo.svg  
public/placeholder-user.jpg
public/placeholder.jpg
public/placeholder.svg
```

**🎯 AI 프롬프트:**
```
Phase 6.1 - 정적 리소스 정리:

1. public/ 폴더에서 다음 placeholder 파일들을 삭제하라:
   - placeholder-logo.png
   - placeholder-logo.svg
   - placeholder-user.jpg  
   - placeholder.jpg
   - placeholder.svg

2. 코드에서 이들 파일을 참조하는 부분이 있는지 검색하고, 있다면 실제 사용하는 이미지로 교체하라

3. 파일 네이밍을 kebab-case로 통일하라:
   - main-image.png ✓ (이미 올바름)
   - user-avatar.svg ✓ (이미 올바름)
```

#### 📝 **Phase 6.2: 문서 체계화**

**🎯 AI 프롬프트:**
```
Phase 6.2 - 문서 정리:

1. docs/ 폴더 내 문서들을 주제별로 재정리하라:
```
docs/
├── api/
│   ├── miso-api-guide.md
│   └── 지식API.md
├── development/
│   └── mindmap-system-prompt.md
└── README.md (통합 가이드)
```

2. CLAUDE.md와 중복되는 내용은 통합하거나 참조로 연결하라
3. 개발자 온보딩 가이드를 작성하라
```

---

### **Phase 7: 테스트 및 검증**

#### 📝 **Phase 7.1: 컴파일 및 빌드 검증**

**🎯 AI 프롬프트:**
```
Phase 7.1 - 컴파일 검증:

1. TypeScript 컴파일 에러 해결:
```bash
npx tsc --noEmit
```

2. 빌드 성공 확인:
```bash
pnpm run build
```

3. 린트 통과 확인:
```bash
pnpm run lint
```

4. 모든 import 에러 해결:
   - 순환 참조 해결
   - 누락된 export 추가
   - 잘못된 경로 수정
```

#### 📝 **Phase 7.2: 기능 검증**

**🎯 AI 프롬프트:**
```
Phase 7.2 - 기능 검증:

1. 개발 서버 정상 구동 확인:
```bash
pnpm run dev
```

2. 주요 기능들 수동 테스트:
   - 로그인/로그아웃
   - 프로젝트 생성/조회
   - 인터뷰 업로드
   - 페르소나 생성
   - 채팅 기능

3. API 엔드포인트 응답 확인:
   - /api/projects
   - /api/interviews  
   - /api/personas
   - /api/persona-criteria

4. 에러 발생 시 로그 확인 및 수정
```

---

## 🚨 예상 에러 및 해결 방법

### **타입 관련 에러**

| 에러 메시지 | 원인 | 해결 방법 |
|-------------|------|-----------|
| `Module '"../lib/data"' has no exported member 'PersonaData'` | lib/data.ts 삭제 후 타입 참조 에러 | `import { PersonaData } from '@/types'`로 변경 |
| `Property 'row_id' does not exist on type 'PersonaData'` | 레거시 타입과 Supabase 타입 불일치 | Supabase 스키마에 맞는 속성으로 수정 |
| `Type 'Project' is not assignable to type 'Project'` | 중복 타입 정의로 인한 충돌 | 하나의 타입만 사용하도록 import 수정 |

### **API 관련 에러**

| 에러 메시지 | 원인 | 해결 방법 |
|-------------|------|-----------|
| `404 Not Found: /api/supabase/projects` | API 경로 변경 후 클라이언트 미업데이트 | 새로운 경로 `/api/projects`로 수정 |
| `fetch is not defined` | 서버 사이드에서 fetch 사용 | Node.js 18+ 사용 또는 polyfill 추가 |
| `Response schema mismatch` | 새로운 응답 형식과 기존 코드 불일치 | 응답 파싱 로직 수정 |

### **Import 관련 에러**

| 에러 메시지 | 원인 | 해결 방법 |
|-------------|------|-----------|
| `Cannot resolve module '@/components/ui'` | 인덱스 파일 생성 전 import 시도 | 인덱스 파일 생성 후 재시도 |
| `Circular dependency detected` | 순환 참조 발생 | 의존성 그래프 분석 후 구조 개선 |
| `Module not found: Can't resolve '../utils'` | 파일 이동 후 경로 미수정 | 새로운 경로로 import 수정 |

---

## 📊 리팩토링 완료 후 기대 효과

### **개발자 경험 개선**
- ✅ 일관된 import 경로
- ✅ 타입 안전성 향상  
- ✅ 코드 자동완성 개선
- ✅ 빌드 시간 단축

### **코드 품질 향상**
- ✅ 레거시 코드 제거
- ✅ RESTful API 구조
- ✅ 일관된 에러 핸들링
- ✅ 모듈화된 구조

### **유지보수성 향상**
- ✅ 도메인별 명확한 분리
- ✅ 공통 로직 중앙화
- ✅ 테스트 용이성 증대
- ✅ 문서화 체계 구축

---

## 🎯 실행 순서 요약

1. **Phase 1**: 타입 시스템 통합 (가장 우선)
2. **Phase 2**: API 라우트 리팩토링  
3. **Phase 3**: 컴포넌트 구조 최적화
4. **Phase 4**: 유틸리티 함수 재구성
5. **Phase 5**: API 계층 최적화
6. **Phase 6**: 정적 리소스 정리
7. **Phase 7**: 테스트 및 검증

각 Phase는 독립적으로 진행 가능하며, Phase 1과 2는 병렬로 진행할 수 있습니다. 모든 단계에서 점진적으로 테스트하여 기존 기능에 영향을 주지 않도록 주의해야 합니다.